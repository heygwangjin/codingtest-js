# 그래프(Graph)

* [그래프의 개념](#그래프의-개념)
  * [그래프 용어 정리](#그래프-용어-정리)
    * [정점](#정점)
    * [간선](#간선)
  * [그래프의 특징과 종류](#그래프의-특징과-종류)
    * [가중치 간선](#가중치-간선)
    * [무방향 그래프](#무방향-그래프)
    * [방향 그래프](#방향-그래프)
    * [가중치 그래프](#가중치-그래프)
    * [순환 그래프](#순환-그래프)
    * [비순환 그래프](#비순환-그래프)
  * [그래프 구현](#그래프-구현)
    * [인접 행렬 그래프 표현](#인접-행렬-그래프-표현)
    * [인접 리스트 그래프 표현](#인접-리스트-그래프-표현)
    * [인접 행렬과 인접 리스트의 장단점](#인접-행렬과-인접-리스트의-장단점)
      * [인접 행렬의 단점](#인접-행렬의-단점)
      * [인접 행렬의 장점](#인접-행렬의-장점)
      * [인접 리스트의 단점](#인접-리스트의-단점)
      * [인접 리스트의 장점](#인접-리스트의-장점)
* [그래프 탐색](#그래프-탐색)
  * [깊이 우선 탐색](#깊이-우선-탐색)
    * [스택을 활용한 깊이 우선 탐색](#스택을-활용한-깊이-우선-탐색)
      * [스택 DFS 코드](#스택-dfs-코드)
    * [재귀 함수를 활용한 깊이 우선 탐색](#재귀-함수를-활용한-깊이-우선-탐색)
      * [재귀 함수 DFS 코드](#재귀-함수-dfs-코드)
  * [너비 우선 탐색](#너비-우선-탐색)
    * [큐를 활용한 너비 우선 탐색](#큐를-활용한-너비-우선-탐색)
      * [큐 BFS 코드](#큐-bfs-코드)
  * [깊이 우선 탐색과 너비 우선 탐색 비교](#깊이-우선-탐색과-너비-우선-탐색-비교)

## 그래프의 개념

* 그래프는 **정점**(vertex)과 **간선**(edge)을 이용한 **비선형 데이터** 구조
* **데이터를 정점**으로, **정점 간의 관계나 흐름을 간선**으로 표현하여 데이터 간의 관계를 표현
* 간선은 방향이 있을 수도 있고 없을 수도 있다.
* 관계나 흐름에서 정도를 표현할 필요가 있다면 **가중치**(weight)라는 개념으로 표현

### 그래프 용어 정리

#### 정점

* 정점은 데이터를 저장

```sh
   A      B      C
```

#### 간선

* 정점들 사이를 연결하는 선

```sh
   A ---- B
```

#### 가중치 간선

* 간선에 **특정 값**을 부여하여 표현
* 이 값은 두 정점 간의 연결에 대한 **중요도**나 **특성**을 나타낸다.

```sh
   A --(5)-- B
```

### 그래프의 특징과 종류

* 그래프는 방향성, 가중치, 순환 특성에 따라 종류를 구분

#### 무방향 그래프

* 각 간선이 방향이 없는 선으로 표시

```sh
   A ---- B ---- C
```

#### 방향 그래프

* 각 간선이 방향을 가지고 있다.

```sh
   A ---> B ---> C
```

* 양방향으로 가리킬 수도 있다.

```sh
   A <---> B <---> C
```

#### 가중치 그래프

* 간선이 가중치를 가지고 있는 그래프

```sh
   A --(3)--> B
```

#### 순환 그래프

* 특정 노드에서 시작해 간선을 따라 **다시 돌아오는 경로가 있는** 그래프

```sh
   A ---> B
    ↖    ↙
     ↖  ↙
      C
```

#### 비순환 그래프

* 특정 노드에서 시작해 간선을 따라 **다시 돌아오는 경로가 없는** 그래프

```sh
   A ---> B
        ↙
       ↙
     C
```

### 그래프 구현

> **문제에서 정점 개수가 1,000개 미만으로 주어지는 경우에는 인접 행렬을 사용!**

#### 인접 행렬 그래프 표현

* 2차원 배열을 활용하여 구현
* 배열의 **인덱스는 정점**, 배열의 **값은 정점의 가중치**
* 2차원 배열의 **행을 출발 정점**, **열을 도착 정점**으로 생각
* 가중치가 없는 경우는 **-1**이나 **굉장히 큰 값**으로 저장

```sh
서울(0) ---(400 km)---> 부산(1)
```

|        | 0     | 1    |
|--------|------ |------|
| 0      | -1    | 400  |
| 1      | -1    | -1   |

#### 인접 리스트 그래프 표현

| 정점(v)   |  가중치(w)     | 다음 노드(next)  |
|-----------|----------------|------------------|

위는 인접리스트용 노드

1. 정점 개수만큼의 길이를 가진  배열을 준비
2. 배열의 **인덱스는 각 시작 정점**을 의미하며 배열의 **값에는 다음 노드**를 연결

#### 인접 행렬과 인접 리스트의 장단점

##### 인접 행렬의 단점

* **희소 그래프**를 표현하는 경우 인접 행렬 공간 중 **대부분의 공간이 낭비**
* 정점의 **값의 차이가 매우 큰 그래프**를 표현하는 경우 **가장 큰 값을 기준으로 인접 행렬의 크기**를 잡아야 함

##### 인접 행렬의 장점

* 2차원 배열이기 때문에 **간선의 정보를 확인할 때 시간 복잡도가 O(1)**
* 구현이 쉬움

##### 인접 리스트의 단점

* 간선 정보를 확인할 때 특정 정점에서 시작하여 **연결된 노드 개수가 많을수록 연결된 간선의 수만큼 탐색**해야하므로 O(M)

##### 인접 리스트의 장점

* 실제 연결된 정점에 대해서만 정점의 값을 노드에 담아 연결하기 때문에 일반적으로 메모리를 효율적으로 사용

|             | 메모리 사용      | 시간 복잡도 | 기타                   |
|-------------|------------------|-------------|------------------------|
| 인접 행렬   | O(N<sup>2</sup>) | O(1)        | 구현이 상대적으로 쉬움 |
| 인접 리스트 | O(N + M)         | O(M)        | M은 간선의 개수        |

## 그래프 탐색

### 깊이 우선 탐색

1. 깊이 우선 탐색(DFS)은 시작 정점부터 탐색을 시작한다.
2. **가장 깊은 정점까지 방문한다**.
3. **더 이상 방문할 정점이 없으면 최근 방문한 정점으로 돌아온다**.(백트래킹)
4. 해당 정점과 **연결된 정점 중 방문하지 않은 정점을 확인**하고 다시 **최대 깊이까지 차례대로 방문**한다.

#### 스택을 활용한 깊이 우선 탐색

스택은 **방문 예정인 정점을 저장**

1. 시작 정점을 스택에 푸시
2. 스택이 비었는지 확인
   * 스택이 비었다면 방문 예정인 정점이 없다는 의미(탐색 종료)
3. 스택을 팝하여 최근 정점을 꺼냄
4. 해당 정점의 방문 여부 확인
   * 방문한 정점인 경우 아무 처리 안 함
   * 방문하지 않은 정점인 경우 방문 처리 후, 해당 정점에 연결된 인접 정점들을 스택에 추가

##### 스택 DFS 코드

```js
function dfsStack(adjList, start) {
   // 1. 시작 정점을 스택에 푸시
   const stack = [start];
   const visited = new Set(); // 방문 여부 기록

   // 2. 스택이 비었는지 확인
   while (stack.length > 0) {
      // 3. 스택을 팝하여 최근 정점을 꺼냄
      const vertex = stack.pop();

      // 4. 해당 정점이 방문하지 않은 정점인 경우
      if (!visited.has(vertex)) {
         visited.add(vertex); // 4. 방문 처리
         console.log(vertex);

         // 4. 인접 정점들을 역순으로 스택에 추가 (역순으로 추가해야 방문 순서를 오름차순으로 할 수 있음)
         const neighbors = adjList[vertex] || [];
         for (let i = neighbors.length - 1; i >= 0; i--) {
            stack.push(neighbors[i]);
         }
      }
   }
}
```

#### 재귀 함수를 활용한 깊이 우선 탐색

* 재귀 함수를 호출할 때마다 **호출한 함수는 콜 스택에 쌓이므로** 깊이 우선 탐색에 활용 가능
* dfs(N): N번 정점을 **방문 처리하고 N번 정점과 인접한 정점 중 아직 방문하지 않은 정점을 탐색**

1. 재귀 호출
   * 현재 정점을 방문 처리
   * 인접 정점들을 하나씩 방문하면서 재귀적으로 탐색
2. 종료 조건
   * 이미 방문한 정점이거나, 더 이상 인접 정점이 없으면 함수 호출을 종료

##### 재귀 함수 DFS 코드

```js
function dfsRecursive(adjList, vertex, visited = new Set()) {
   if (!visited.has(vertex)) {
      // 1. 현재 정점을 방문 처리
      visited.add(vertex);
      console.log(vertex); // 방문한 정점 출력

      const neighbors = adjList[vertex] || []; // 인접 정점 가져오기
      for (let neighbor of neighbors) {
         // 1. 인접 정점들 모두 재귀호출
         dfsRecursive(adjList, neighbor, visited);
      }
   }
}
```

### 너비 우선 탐색

1. 너비 우선 탐색(BFS)은 시작 정점부터 탐색을 시작한다.
2. 시작 정점과 **거리가 가장 가까운 정점을 우선**하여 차례대로 방문한다.(거리는 시작 정점과 목표 정점까지의 차수)

#### 큐를 활용한 너비 우선 탐색

큐에 있는 정점은 **이미 방문 처리** 했고, 그 **정점과 인접한 정점은 아직 탐색하지 않은 상태**

1. 시작 정점을 방문 처리 후 큐에 푸시
2. 큐가 비었는지 확인
    * 큐가 비었다면 방문할 수 있는 모든 정점을 방문했다는 의미(탐색 종료)
3. 큐에서 정점을 팝
4. 팝한 정점과 **인접한 모든 정점을 확인하여 아직 방문하지 않은 정점들을 방문처리 후 큐에 푸시**

##### 큐 BFS 코드

```js
function bfs(graph, start) {
   // 그래프를 인접 리스트로 변환
   const adjList = {};
   for (const [u, v] of graph) {
      if (!adjList[u]) adjList[u] = [];
      adjList[u].push(v);
   }

   const visited = new Set(); // 방문한 정점을 저장할 Set

   // 1. 시작 정점 방문 처리 후 큐에 푸시
   const queue = [];
   visited.add(start);
   queue.push(start);

   // 2. 큐가 비어있지 않다면 반복
   while (queue.length > 0) {
      // 3. 큐에서 정점을 팝
      const vertex = queue.shift();
      console.log(vertex); // 방문한 정점 출력

      // 4. 인접한 모든 정점들에 대해
      for (const neighbor of adjList[vertex] || []) {
         // 4. 방문하지 않은 인접 정점인 경우
         if (!visited.has(neighbor)) {
            // 4. 방문 처리 후 큐에 푸시
            visited.add(neighbor);
            queue.push(neighbor);
         }
      }
   }
}
```

### 깊이 우선 탐색과 너비 우선 탐색 비교

* 깊이 우선 탐색은 **깊게 탐색 후 되돌아오는** 특성
  * 모든 가능한 해를 찾는 **백트래킹 알고리즘**
  * 그래프의 사이클을 감지해야하는 경우
* 너비 우선 탐색은 **시작 노드에서 인접한 노드부터 방문**하는 특성
  * 시작 노드에서 인접한 노드부터 방문하기 때문에 **최단 경로**임을 보장
  * 문제에 대한 답이 많은 경우 너비 우선 탐색은 이 답 중에서도 **가장 가까운 답**을 찾을 때 유용

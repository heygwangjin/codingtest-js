# 집합 (Set)

## 집합과 상호배타적 집합의 개념

### 집합의 개념

- **순서와 중복이 없는** 원소들을 갖는 자료구조

### 상호배타적 집합의 개념

- **교집합이 없는 집합 관계**를 의미
- 두 집합 A와 B가 **공통 원소를 가지지 않으면** 두 집합은 상호배타적 집합
- `ex. A = {1, 2, 3}, B= {4, 5, 6, 7}`

## 집합의 연산

- 보통 집합은 **트리**로 표현
- 대표적인 연산은 **합치기** (Union)와 **탐색** (Find)

### 배열을 활용한 트리로 집합 표현하기

- 각 집합에는 대표 원소가 있어야한다.

#### 대표 원소의 개념

- 집합의 원소 중 집합을 대표하는 역할
- 집합의 형태를 트리로 표현하는 경우, 대표 원소는 **루트 노드**를 의미

#### 배열로 집합을 표현하는 것이란?

- 하나의 배열로 상호배타적 관계를 가지는 집합을 모두 표현
- **배열의 인덱스는 자신을, 배열값은 부모 노드**를 의미 (집합을 트리 형태로 표현할 때)
- `ex. disjointSet[3] = 9` 이면, 노드 3의 부모 노드는 9
- 루트 노드는 집합의 대표이므로 부모가 없고, **부모 노드가 자기 자신** (값 자체가 배열의 인덱스와 동일)
- 배열의 크기는 **배열의 인덱스가 모든 집합의 원소를 표현**할 수 있으면 된다.
- 집합의 개수는 루트 노드의 개수

### 유니온-파인드 알고리즘

- 합치기는 유니온, 탐색은 파인드

#### 파인드 연산

- 특정 노드의 **루트 노드가 무엇인지 탐색**하는 방법
- 특정 노드가 **같은 집합에 있는지 확인**할 때 사용 (두 노드의 루트 노드가 같다면 같은 집합)
- 파인드 연산은 **재귀 함수**로 구현
- 시간복잡도는 O(N)

##### 파인드 연산의 연산 과정

1. 현재 노드의 부모 노드를 확인한다. 부모 노드를 확인하다가 부모 노드가 루트 노드이면 파인드 연산 종료
2. 1에서 파인드 연산이 종료되지 않으면 1을 반복

#### 파인드 연산의 연산 비용 문제, 경로 압축으로 해결

- 파인드 연산의 목표는 **루트 노드** 찾기이므로 **부모 노드**를 거치는 과정은 비효율적
- 집합 형태를 유지하면서 트리 높이를 줄인다.
- 경로 압축은 집합을 구성하는 트리를 평평하게 만들어서 파인드 연산을 효율적으로 할 수 있게 한다.

#### 유니온 연산

- 두 집합을 **하나로 합치는** 연산 (두 집합의 루트 노드를 같게 한다는 의미)
- 합칠 때 루트 노드는 **두 집합의 루트 노드 중 하나**
- 연산을 마친 후, **두 집합 중 하나의 루트 노드는 다른 집합의 루트 노드를 부모**로 가지게 된다.

##### 유니온 연산의 연산 과정

1. 두 집합에서 파인드 연산을 통해 루트 노드를 찾는다.
2. 찾은 두 루트 노드의 값을 비교한다.
3. 두 집합의 루트 노드를 같게한다. (둘 중 아무거나)

#### 유니온 연산의 연산 비용 문제 랭크로 해결

- 파인드 연산처럼 트리의 깊이가 깊어질수록 연산 비용이 커진다.
- 이를 개선하기 위해 랭크라는 개념이 필요

##### 랭크란?

- 현재 노드를 기준으로 하였을 때 **가장 깊은 노드까지의 경로 길이**

##### 랭크 기반으로 유니온 연산하기

1. 두 노드의 루트 노드를 구한다.
2. 1에서 구한 루트 노드의 랭크를 비교
    1. 랭크값이 다르면 **랭크값이 큰 루트 노드를 기준**으로 삼는다. 즉, **랭크가 더 큰 루트 노드를 랭크가 작은 루트 노드의 부모 노드**로 바꾼다. (랭크의 값은 변하지 않는다.)
    2. 랭크값이 같으면 루트 노드를 아무거나 선택해서 바꾸고 **최종 루트 노드의 랭크에 1을 더한다**.
